package org.stellar.kotlinwalletsdk.utils

import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import java.net.URL
import org.stellar.kotlinwalletsdk.OkHttpUtil
import org.stellar.sdk.KeyPair
import org.stellar.sdk.Network
import org.stellar.sdk.Sep10Challenge

class Sep10Client(
  private val endpoint: String,
  private val serverAccount: String,
  private val walletAccount: String,
  private val signingKeys: Array<String>
) : SepClient() {
  constructor(
    endpoint: String,
    serverAccount: String,
    walletAccount: String,
    signingSeed: String
  ) : this(endpoint, serverAccount, walletAccount, arrayOf(signingSeed))

  fun auth(): String {
    // Call to get challenge
    val challenge = challenge()
    println("challenge: $challenge")
    // Sign challenge
    val txn = sign(challenge, signingKeys, serverAccount)
    println("txn: $txn")
    // Get token from challenge
    val token = validate(ValidationRequest.of(txn))!!.token!!

    println("token: $token")

    return token
  }

  fun challenge(): ChallengeResponse {
    val url = String.format("%s?account=%s", this.endpoint, walletAccount)
    val responseBody = httpGet(url)
    return Gson().fromJson(responseBody, ChallengeResponse::class.java)
  }

  private fun sign(
    challengeResponse: ChallengeResponse,
    signingKeys: Array<String>,
    serverAccount: String
  ): String {
    val url = URL(endpoint)
    val webAuthDomain = url.authority
    val challengeTransaction =
      Sep10Challenge.readChallengeTransaction(
        challengeResponse.transaction,
        serverAccount,
        Network(challengeResponse.networkPassphrase),
        webAuthDomain, // TODO: home domain may be different than WEB_AUTH_DOMAIN
        webAuthDomain
      )
    for (signingKey in signingKeys) {
      challengeTransaction.transaction.sign(KeyPair.fromSecretSeed(signingKey))
    }
    return challengeTransaction.transaction.toEnvelopeXdrBase64()
  }

  fun validate(validationRequest: ValidationRequest): ValidationResponse? {
    val request = OkHttpUtil.buildJsonPostRequest(this.endpoint, validationRequest.toString())
    val response = client.newCall(request).execute()
    if (response.code() != 200) {
      throw Exception("Error validating SEP10 transaction")
    }
    val responseBody = response.body()!!.string()
    return Gson().fromJson(responseBody, ValidationResponse::class.java)
  }
}

// Helpers
class ChallengeRequest {
  var account: String? = null
  var memo: String? = null

  //  @org.gradle.internal.impldep.com.fasterxml.jackson.annotation.JsonProperty("home_domain")
  var homeDomain: String? = null

  //  @org.gradle.internal.impldep.com.fasterxml.jackson.annotation.JsonProperty("client_domain")
  var clientDomain: String? = null

  companion object {
    fun of(
      account: String?,
      memo: String?,
      homeDomain: String?,
      clientDomain: String?
    ): ChallengeRequest {
      val challengeRequest = ChallengeRequest()
      challengeRequest.account = account
      challengeRequest.memo = memo
      challengeRequest.homeDomain = homeDomain
      challengeRequest.clientDomain = clientDomain
      return challengeRequest
    }
  }
}

class ChallengeResponse {
  var transaction: String? = null

  //
  // @org.gradle.internal.impldep.com.fasterxml.jackson.annotation.JsonProperty("network_passphrase")
  @SerializedName(value = "network_passphrase") var networkPassphrase: String? = null

  companion object {
    fun of(transaction: String?, networkPassphrase: String?): ChallengeResponse {
      val challengeResponse = ChallengeResponse()
      challengeResponse.transaction = transaction
      challengeResponse.networkPassphrase = networkPassphrase
      return challengeResponse
    }
  }
}

class ValidationRequest {
  var transaction: String? = null

  companion object {
    fun of(transaction: String?): ValidationRequest {
      val validationRequest = ValidationRequest()
      validationRequest.transaction = transaction
      return validationRequest
    }
  }
}

class ValidationResponse {
  var token: String? = null

  companion object {
    fun of(token: String?): ValidationResponse {
      val validationResponse = ValidationResponse()
      validationResponse.token = token
      return validationResponse
    }
  }
}
